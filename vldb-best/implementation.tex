\section{Implementation}\label{sec:implementation}

\subsection{Formal verification}

We have formalized and verified all the definitions, lemmas,
propositions, theorems, and examples in this paper using the Lean theorem prover; we make
these proofs available at~\cite{dbsp-theory}.
% This amounted to roughly 5K lines of Lean code.
The formalization builds on mathlib~\cite{mathlib2020}, which provides
support for groups and functions with finite support (modeling
\zrs). We believe the simplicity of \dbsp enabled completing these
proofs in relatively few lines of Lean code (5K) and keeping a close
correspondence between the paper proofs in~\cite{tr} and Lean.

\subsection{The \dbsp Rust runtime}

We have built an implementation of \dbsp as part of an
open-source project with an MIT license:
\url{https://github.com/feldera/feldera}.
The implementation consists of a Rust library and a runtime.
The library provides APIs for basic algebraic data types:
such as groups, finite maps, \zr, indexed \zr.
A separate circuit construction API allows users to
create \dbsp circuits by placing operator nodes (corresponding to boxes in our diagrams)
and connecting them with streams, which correspond to the
arrows in our diagrams.  The library provides pre-built generic operators
for integration, differentiation, delay, nested integration and differentiation,
and a rich library of \zr basic incremental operators:
corresponding to plus, negation, grouping, joining, aggregation, $\distinct$,
flatmap, window aggregates, etc.

For iterative computations the library provides the $\delta_0$ operator and
an operator that approximates $\int$ by terminating iteration of
a loop at a user-specified condition (usually the condition is the
requirement for a zero to appear in a specified stream).
The low level library allows users to construct incremental
circuits manually by stitching together incremental versions of primitive operators.

The library supports data-parallel multicore evaluation of circuits
using a natural sharding strategy, and a variety of adapters for
external data sources (e.g., Kafka, CSV files, etc).  The library can
also spill internal operator state to persistent storage.  Benchmark
results (which are very promising) are available in the code
repository and will be discussed in future work.

\subsection{Parallelization and Scale-out}

\subsection{State management}

\textbf{Tradeoffs.}  Incremental computation is not free.  It is in
fact a trade-off between time and space.  In the cost analysis we have
to consider both the time and the space used by each operator.  While
many incremental database operations can be implemented using work
proportional to the size of the changes, and no storage overhead,
several classes of database operations, such as joins, ``distinct'',
and aggregates can be implemented efficiently only using additional
storage in the form of \emph{indexes}.  The size of these indexes is
proportional to the size of the total data in the database (and not
just to the size of the changes) --- and since some indexes are over
intermediate relations, they can even exceed the size of the original
database.  In \dbsp the indexes are represented by delay operators
$\zm$.  In fact, the delay operator (and its lifted variant
$\lift{\zm}$) are the only operators that maintains state.  This is
also the only state that needs to be persisted, checkpointed, or
migrated to make \dbsp computations fault-tolerant.

\dbsp is an ``eager'' or ``top-down'' execution model: it constantly
maintains the entire contents of any number of views, even if no one
really wants to inspect the views.  In contrast, ``lazy'' or
``bottom-up'' models only build part of the views when the views are
inspected.  Such models have the potential to be more efficient.
Eager models can be converted into lazy ones if something is known
about the class of operations that will be executed against the views.



TODO: the LSM data structure, storage organization

\subsubsection{Checkpointing and fault-tolerance}

\subsection{SQL compiler}

We have also built a SQL to \dbsp compiler, which translates standard
SQL queries into \dbsp circuits.  The compiler implements
Algorithm~\ref{algorithm-inc}, to generate a streaming version of any
SQL query.  The compiler is open-source
\url{https://github.com/feldera/feldera/sql-to-dbsp-compiler} with
an MIT license.  The compiler front-end parser and optimizer are based
on the Apache Calcite~\cite{begoli-icmd18} infrastructure.  The
project is mature enough to pass all 7 million SQL Logic
Tests~\cite{sqllogictest}.  The compiler handles all aspects of SQL,
including NULLs, ternary logic, grouping, aggregation, multiset
queries, etc.  Currently correlated sub-queries and outer joins are
essentially converted to equivalent relational plans using multiple
joins.

\subsection{Streaming SQL extensions}

